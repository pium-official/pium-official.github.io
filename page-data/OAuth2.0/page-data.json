{"componentChunkName":"component---src-templates-post-jsx","path":"/OAuth2.0/","result":{"data":{"site":{"siteMetadata":{"title":"pium.log"}},"markdownRemark":{"id":"ed5951d5-beda-5a8f-adb2-07c2fcb38d5e","excerpt":"이 글은 우테코 피움팀 크루 '클린'가 작성했습니다. OAuth란? 현재 개발하고 있는 서비스에서 구글 캘린더에 접근을 한다고 가정을 해봅시다. 현재 접근하는 사용자의 구글 캘린더 정보를 얻고자 한다면 구글 계정으로 로그인을 해야합니다. 진짜 간단한 방법이 있습니다. 사용자로부터 구글 id와 password를 받고 저희가 대신 로그인 해서 해당 사용자의 …","html":"<blockquote>\n<p>이 글은 우테코 피움팀 크루 '<a href=\"https://github.com/hozzijeong\">클린</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>OAuth란?</h2>\n<p>현재 개발하고 있는 서비스에서 구글 캘린더에 접근을 한다고 가정을 해봅시다. 현재 접근하는 사용자의 구글 캘린더 정보를 얻고자 한다면 구글 계정으로 로그인을 해야합니다. 진짜 간단한 방법이 있습니다. 사용자로부터 구글 id와 password를 받고 저희가 대신 로그인 해서 해당 사용자의 계정 정보를 받아오는 것입니다.</p>\n<p>하지만 이 방법은 매우 위험합니다. 계정 정보가 탈취당할 수도 있고, 애초에 <strong>대리 로그인</strong>이라니 신개념 보이스피싱으로 오해받을 수도 있습니다.</p>\n<p>제일 괜찮은 방법은 구글 자체에서 로그인 서비스를 대체할 수 있는 방식을 만들어서 제공을 하는 것입니다. 실제로  과거에 AuthSub라는 자체 개발한 방법을 통해 구현을 했지만 이 정형화 되지 않은 방법은 다양한 문제를 야기할 수 있었습니다. 흔히 카카오 로그인, 구글 로그인, 깃헙 로그인 등등 여러가지의 방식이 존재하는데 형식이 통일되어 있지 않다면 이 모든 것들을 각각 구현해서 사용을 해야하는 문제점이 있습니다. </p>\n<p>이러한 문제점을 해결하기 위해 나타난 개념이 OAuth입니다. 초기 버전인 1.0은 범위문제, 불확실한 역할, 보안 문제등으로 인해서 많이 사용 되지 않고 OAuth 2.0이 통상적으로 많이 사용 되고 있습니다. </p>\n<blockquote>\n<p>💡 <strong>인증과 인가</strong>: 인증은 요청자의 신원을 확인하는 것이고, 인가는 신원이 확인된 어느 사람이 권한이 있는지를 확인하는 것입니다. 개인적으로 생각했을때 인증은 사람의 직업 검증하는 것이고 인가는 그 사람의 직책을 통해 권한을 접근한다고 생각합니다. (직책에 따른 정보 접근 권한이 다르기 때문)</p>\n</blockquote>\n<h2>OAuth 2.0</h2>\n<p>OAuth2.0을 이해하기 위해서는 크게 4가지 용어를 알고 있으면 됩니다. 바로 Resource Owner, Client, Resource Server, Authorization Server입니다. 각각의 역할과 설명은 다음과 같습니다.</p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/c65c8e80-b04a-4b51-b66a-dbdd6d43b543\" alt=\"image\"></p>\n<ul>\n<li><code class=\"language-text\">Resource Owner</code><strong>:</strong> 리소스(정보)의 주인. 즉,서비스를 이용하고자 하는 사용자를 의미합니다.</li>\n<li><code class=\"language-text\">Client</code>: 리소스(정보)를 가공 혹은 Resource Owner에게 제공하는 주체. OAuth 2.0을 개발하는 어플리케이션(서비스)을 의미한다.</li>\n<li><code class=\"language-text\">Resource Server</code>: 리소스(정보)를 갖고 있는 주체. 흔히 카카오, 구글, Github등 사용자 정보를 제공하는 주체를 의미한다.</li>\n<li><code class=\"language-text\">Authorization Server</code>: Resource Owner를 인증하고, Client에 인가를 할당하는 역할이다.</li>\n</ul>\n<p>OAuth를 가장 많이 도입한 기능 중 하나는 소셜 로그인입니다. 하나의 예시를 들어보겠습니다. 사용자가 Todo앱에 접근하려고 합니다. 사용자의 Todo인지를 확인하기 위해서는 로그인 기능이 필요합니다. 그런데 사용자는 회원가입을 하기 귀찮습니다. 이 과정에서 사용자의 기본 정보 (이메일, 닉네임, 프로필 사진 등)를 갖고 있는 소셜 네트워크가 있다고 생각해 봅시다. Client는 이 소셜 네트워크를 통해서 사용자에게 간단한 회원가입/로그인 기능을 제공할 수 있습니다. 이제 본인이 Todo앱에 회원가입을 하고, 나의 Todo를 카카오 스토리에 공유한다고 상상하고 OAuth의 동작과정에 대해 한번 알아보겠습니다.</p>\n<blockquote>\n<p>💡 OAuth에는 크게 4가지 grant(승인 방식)가 있는데, 이번에 다루는 승인 방식은 기본적으로 사용되고 있는 <strong>Authorization Code Grant(권한 부여 승인 코드 방식)</strong> 을 통해 기준으로 설명하겠습니다.</p>\n</blockquote>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/e4f90a4b-6783-4d32-974a-2fdc2c5d3ae3\" alt=\"image\"></p>\n<ul>\n<li>\n<p>첫 번째는 로그인 요청입니다. 흔히 우리가 알고있는 “카카오로 로그인하기”를 클릭 했을 때 나오는 설정되는 방식입니다. 이때 Authorization Server에 4가지 파라미터를 동봉해서 보냅니다.</p>\n<ul>\n<li>client_id(required): Server에서 발급받은 인증 id입니다.</li>\n<li>redirect<em>uri(optional): Server에 등록할 때 함께 입력한 redirect</em>uri입니다.</li>\n<li>response_type(required): 반드시<code class=\"language-text\">code</code>로 설정해야 합니다.</li>\n<li>scope(optional): 제공하는 정보 범위를 설정합니다.</li>\n</ul>\n</li>\n<li>Authorization Server에서 Resource Owner에게 아이디와 비밀번호를 요구합니다. 사용자 인증이 된다면, 미리 입력받은 redierct_uri로 이동합니다.</li>\n<li>해당 uri로 리다이렉트 되면서 함께 동봉되어 온 Authorization Code를 받고 이 코드를 Access Token으로 교환합니다.</li>\n<li>교환한 Access Token을 통해서 Resource Server에서 원하는 데이터를 얻을 수 있습니다. (Todo일정을 카카오 스토리에 공유할 수 있습니다!!)</li>\n</ul>\n<p>위와 같은 과정을 통해서 OAuth를 통해서 제 3의 서비스에서 사용자의 정보에 인가를 받아서 가공하거나 직접적으로 제공할 수 있습니다.</p>\n<p>사용자로부터 로그인 정보를 받아서 로그인을 하고 사용자의 권한을 부여받은 Access Token을 통해서 Reource Server로부터 데이터를 얻는 것입니다.</p>\n<hr>\n<h3>OAuth공부를 하면서 들었던 의문점</h3>\n<p>Access Token을 통해서 Resource에 있는 데이터를 얻는 것은 알겠는데, 그래서 이게 로그인이랑 어떤 관련이 있는가? 그리고, Client DB에 있는 데이터나 API랑도 관련이 있나?</p>\n<p>Authorization Server를 통해서 넘겨받은 Access Token을 활용하면 소셜 로그인을 구현할 수 있었고, 해당 토큰을 통해서 모든 정보에 접근이 가능하겠구나 생각을 했었습니다. 하지만, 이 Access Token은 Resource Server에 있는 데이터를 얻는데 필요한 Access Token이고 <strong>Client 내부에서 접근하는 DB와 API랑은 관련이 없다는 것입니다.</strong></p>\n<p>Client에서는 넘겨받은 Access Token을 통해서 개별적으로 구축한 member DB에서 해당 유저를 식별하고, 그에 맞는 로그인 기능을 구현해야 합니다.</p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/e6c1a44b-6e6e-4034-bca6-cfe9e2c5d8c0\" alt=\"image\"></p>\n<p>로그인 기능을 개별적으로 구현해야 한다는 얘기를 듣고, Client의 역할을 어떻게 분리가 되는지에 대해 의문이 들었습니다. 여기서 Client는 사용자가 이용하는 앱 서비스인데, 사용자와 직접적인 인터렉션을 하는 Client(FE)와 데이터를 제공하는 Sever(BE)로 분리가 됩니다. </p>\n<p>그렇다면 OAuth를 이용한 서비스를 구현할 때 Client안에서는 어떤 일이 일어날까요?</p>\n<ol>\n<li>사용자 로그인 페이지 제공 (FE)</li>\n<li>redirect_uri로 이동시키고, 넘겨받은 Autorization Code를 BE로 넘겨줌 (FE)</li>\n<li>FE로부터 넘겨받은 Autorization Code를 Authorization Server에 전달하고, Access Token과 Refresh Token을 받음(BE)</li>\n<li>넘겨 받은 Access Token을 통해 Resource Owner 정보 조회(BE)</li>\n<li>DB Table에 해당 유저 확인 후 Client Session이나 Client Token 전달(BE)</li>\n<li>전달 받은 Session이나 Token을 통해서 유저 로그인 유지 (FE)</li>\n<li>사용자가 Client의 서비스를 이용하고자 할 때 Client Session을 통해 인증을 함 (FE)</li>\n<li>Client에서 제공하고자 하는 데이터가 Resource Server에서 얻어야 하는 데이터라면, 저장해 놓았던 Access Token을 통해 Resource Server로 부터 데이터를 받아옴. 그리고 Client에서 제공하는 API와 잘 조합해서 데이터 제공(BE)</li>\n<li>사용자가 확인 가능하게 UI제공 (FE)</li>\n</ol>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/a668a660-8b62-4fbd-8caf-e3998c570a1c\" alt=\"image\"></p>\n<p>Client에서의 역할을 나눠보면 다음과 같습니다.</p>\n<h3>FE</h3>\n<ul>\n<li>로그인 페이지 제공</li>\n<li>redirect_uri를 통해 Authorization Code 전달</li>\n<li>Resource Server에 맞는 UI 제공</li>\n</ul>\n<h3>BE</h3>\n<ul>\n<li>전달받은 Authorization Code를 통해 Access Token 교환</li>\n<li>Access Token을 통해 Resource Server에 있는 데이터 요청 및 가공</li>\n<li>Access Token만료 시 Refresh Token으로 Access Token 갱신</li>\n</ul>\n<hr>\n<h3>참조</h3>\n<p><a href=\"https://blog.naver.com/mds_datasecurity/222182943542\">OAuth의 인증 종류</a></p>\n<p><a href=\"https://hudi.blog/oauth-2.0/\">OAuth의 개념과 동작 원리</a></p>","frontmatter":{"title":"내가 이해한 OAuth2.0","date":"August 10, 2023","update":"August 10, 2023","tags":["OAuth2.0"],"series":null},"fields":{"slug":"/OAuth2.0/","readingTime":{"minutes":10.725}}},"seriesList":{"edges":[{"node":{"id":"28f1d87e-d3fc-5567-8531-57649652864f","fields":{"slug":"/sprint-idea/"},"frontmatter":{"title":"구글 스프린트 기반 아이디어 도출"}}},{"node":{"id":"4a9246fb-171b-5973-88fc-864034e78afd","fields":{"slug":"/blog-starter/"},"frontmatter":{"title":"피움 블로그 생성과정"}}},{"node":{"id":"c826ce0e-1ea7-517c-8d19-84e90a59a798","fields":{"slug":"/jenkins-setting/"},"frontmatter":{"title":"젠킨스 설치하기"}}},{"node":{"id":"a387bf4f-567f-50e7-b6a7-99a1a1c8971b","fields":{"slug":"/jpa-notnull-nullable/"},"frontmatter":{"title":"@NotNull과 nullable = false는 어떤 차이가 있을까?"}}},{"node":{"id":"a78e224b-b711-5071-8e90-013d6f4bebc3","fields":{"slug":"/pium-deploy-step/"},"frontmatter":{"title":"피움의 배포과정"}}},{"node":{"id":"ce07fbab-1ed5-5f1e-8e2f-eb430879b56a","fields":{"slug":"/fe-tanstack-query/"},"frontmatter":{"title":"프론트엔드: Tanstack Query 사용에 대하여"}}},{"node":{"id":"159c943b-1a50-57dd-aa71-7557364752a5","fields":{"slug":"/ci-cd-setting/"},"frontmatter":{"title":"Jenkins와 Github Webhook을 이용해 CI/CD 구축하기"}}},{"node":{"id":"dea45a4a-bfde-5fbb-8a97-42d3a3e77a0b","fields":{"slug":"/jenkins-hook-by-label/"},"frontmatter":{"title":"PR 라벨로 젠킨스 빌드유발을 구분하기"}}},{"node":{"id":"1a03734e-d413-553f-9152-1dad2fc4acca","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"내 서버에 HTTPS 설정하기"}}},{"node":{"id":"707f8ffb-1409-5c27-b15a-5661b235c226","fields":{"slug":"/db-drop-stop/"},"frontmatter":{"title":"Table Drop 못하게 막아버리기"}}},{"node":{"id":"cecbc8b9-db00-562b-aa0b-06c406cfc44a","fields":{"slug":"/bundle-analyze/"},"frontmatter":{"title":"bundle-analyze를 통한 bundle 크기 분석"}}},{"node":{"id":"fe4b591a-4dd5-5dd2-b18a-b318afd1e9e3","fields":{"slug":"/transactional-not-in-restassured/"},"frontmatter":{"title":"[트러블슈팅] @SpringbootTest의 RANDOM_PORT 환경에서 @Transactional 어노테이션을 사용했을 때, RestAssured GET 요청이 수행되지 않는 경우(트랜잭션 격리 이해하기)"}}},{"node":{"id":"80aa708e-ef8a-5c79-9644-cb8c04d55a63","fields":{"slug":"/acceptance-test-resolve/"},"frontmatter":{"title":"인수테스트 데이터 초기화하기"}}},{"node":{"id":"15def1d5-c20f-5d07-b46e-24a14661365f","fields":{"slug":"/react-setting-without-cra/"},"frontmatter":{"title":"webpack으로만 React 설정하기 (without CRA)"}}},{"node":{"id":"66383c86-e2c8-533a-90e0-2effae572742","fields":{"slug":"/stylelint-and-husky/"},"frontmatter":{"title":"stylelint와 husky를 통해 컨벤션 통일하기"}}},{"node":{"id":"ed5951d5-beda-5a8f-adb2-07c2fcb38d5e","fields":{"slug":"/OAuth2.0/"},"frontmatter":{"title":"내가 이해한 OAuth2.0"}}},{"node":{"id":"45eeb9a3-557d-5704-8fd9-925283e1e27b","fields":{"slug":"/restdocs-start/"},"frontmatter":{"title":"RestDocs로 API 문서화하기"}}},{"node":{"id":"663b560a-734d-51a9-a6dc-3c4f50716c74","fields":{"slug":"/spring-event-apply/"},"frontmatter":{"title":"Spring Event 적용하기"}}},{"node":{"id":"55ae8038-3f65-5a59-8db3-c7405e7fc125","fields":{"slug":"/github-actions-cypress/"},"frontmatter":{"title":"피움 Cypress 자동화 구축기"}}},{"node":{"id":"503e9e71-eda3-53d7-8142-7c309faf213e","fields":{"slug":"/why_we_applied_querydsl/"},"frontmatter":{"title":"피움 서비스의 Querydsl 도입 이유"}}},{"node":{"id":"709124d0-5b05-5530-804d-e90ec9856a13","fields":{"slug":"/querydsl_apply_procedure/"},"frontmatter":{"title":"피움 서비스의 Querydsl 적용 과정"}}},{"node":{"id":"5c865dcb-cefd-58be-8968-b5edf6c8080c","fields":{"slug":"/server-logging/"},"frontmatter":{"title":"Logback을 이용해 운영 환경 별 로그 남기기"}}}]},"previous":{"fields":{"slug":"/stylelint-and-husky/"},"frontmatter":{"title":"stylelint와 husky를 통해 컨벤션 통일하기"}},"next":{"fields":{"slug":"/restdocs-start/"},"frontmatter":{"title":"RestDocs로 API 문서화하기"}}},"pageContext":{"id":"ed5951d5-beda-5a8f-adb2-07c2fcb38d5e","series":null,"previousPostId":"66383c86-e2c8-533a-90e0-2effae572742","nextPostId":"45eeb9a3-557d-5704-8fd9-925283e1e27b"}},"staticQueryHashes":[],"slicesMap":{}}