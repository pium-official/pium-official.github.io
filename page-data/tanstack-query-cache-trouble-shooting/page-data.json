{"componentChunkName":"component---src-templates-post-jsx","path":"/tanstack-query-cache-trouble-shooting/","result":{"data":{"site":{"siteMetadata":{"title":"pium.log"}},"markdownRemark":{"id":"0faec7ad-3bd1-5f5e-9222-115f771df8ed","excerpt":"이 글은 우테코 피움팀 크루 '클린'가 작성했습니다. 문제: 무한 스크롤 시에 데이터 fetch가 제대로 이루어지지 않는다. 에러 구현 방법: 특정 식물 상세보기 접속 → 타임라인 페이지 접속 → 뒤로가기 → 해당 식물 정보 수정 → 타임라인 페이지 접속 서론 ‘피움’ 서비스 에서는 식물의 관리 이력(식물 물 주기, 물 주기 Cycle 변화, 식물의 환경…","html":"<blockquote>\n<p>이 글은 우테코 피움팀 크루 '<a href=\"https://github.com/hozzijeong\">클린</a>'가 작성했습니다.</p>\n</blockquote>\n<h3>문제: 무한 스크롤 시에 데이터 fetch가 제대로 이루어지지 않는다.</h3>\n<h3>에러 구현 방법: 특정 식물 상세보기 접속 → 타임라인 페이지 접속 → 뒤로가기 → 해당 식물 정보 수정 → 타임라인 페이지 접속</h3>\n<h2>서론</h2>\n<p>‘피움’ 서비스 에서는 식물의 관리 이력(식물 물 주기, 물 주기 Cycle 변화, 식물의 환경 변화 등)을 확인할 수 있는 ‘타임라인’ 서비스를 제공하고 있습니다. 이 타임라인 기능에서는 다른 페이지로 이동할 필요 없이 아래로만 스크롤 하면 다음 데이터가 나오는 ‘무한 스크롤’ 기능을 사용자들에게 제공하고 있는데, 이 무한 스크롤을 좀 더 편리하게 사용하기 위해서 React-Query에서 제공하는 <a href=\"https://tanstack.com/query/v5/docs/react/reference/useInfiniteQuery\">useInfiniteQuery</a>를 통해 무한 스크롤을 구현하고 있습니다. </p>\n<h3>본론</h3>\n<p>사건의 발단은 다음과 같습니다. 식물의 관리 이력을 수정하고 변경 내역이 타임라인에 기록되었는지를 확인하기 위해 타임라인을 클릭 했더니 <strong>수정하기 전 타임라인을 제공하고 있던 것이었습니다.</strong> 당시에 운영 서비스 배포하기로 결정한 당일 이었기 때문에 상당히 당황한 기억이 있습니다. </p>\n<p>문제를 찾아보기 위해 <code class=\"language-text\">console</code>을 통해서 데이터 fetch 순서를 한번 봤습니다. 처음에 접속해서 캐시되어 있던 데이터가 먼저 찍히는 것을 볼 수 있습니다. 그 다음에 타임라인에 사용될 데이터를 보여주고, 데이터 통신이 완료가 됩니다. <code class=\"language-text\">GET /history</code> 이력을 보면 데이터 fetch가 완료된 것을 볼 수 있는데, 데이터 fetch를 하고 끝이 납니다. 마지막으로 fetch한 데이터가 가장 최신의 데이터이고 타임라인에 적용되어야 할 데이터인데, 전혀 적용되지 않고 fetch만 하고 끝이 됩니다. 이 때문에 타임라인에는 이전 내용이 적용되어서 데이터가 나타나는 것입니다. 문제는 언제는 또 제대로 작동이 된다는 것 이었습니다. 이렇게 일관성 없는 fetch 동작에 상당히 많은 혼란이 있었습니다.</p>\n<ul>\n<li><code class=\"language-text\">Response Data</code>: 처음 fetch 되었을 때 나온 데이터</li>\n<li><code class=\"language-text\">Select Data</code>: fetch된 데이터를 가공하기 위해 <code class=\"language-text\">select</code> 옵션을 사용한 과정에서 찍히는 데이터</li>\n<li><code class=\"language-text\">TimeLine Data</code>: 실제 타임라인에 사용될 데이터</li>\n</ul>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/3b122e0d-2404-41a6-856e-0f937de9938c\" alt=\"image\"></p>\n<p>문제의 원인을 ‘캐시된 데이터’라고 추정한 가운데 생각한 해결책은 ‘데이터를 fetch 할 때마다 캐시를 하지 않게 하려면 어떻게 해야 하나?’ 였습니다. React-Query에 대해서 좀 더 자세히 알고 있었다면 금방 해결 됐을 문제이지만, 옵션 들에 대해 그렇게 자세하게 알지 못했고, 애꿎은 <code class=\"language-text\">queryKey</code>와 <code class=\"language-text\">enable</code> 등을 건드렸다. <a href=\"https://tanstack.com/query/v4/docs/react/guides/dependent-queries\">Dependent Queries</a>를 사용하면서, enable 옵션에 상태 값을 할당하는데, 바로 호출하는 방식이 클로저에 갇혀서 계속 같은 값으 제공하나? 이런 생각도 하고, queryKey가 같아서 계속 캐싱을 하나… filter를 없애야 하나 하는 생각도 했습니다. </p>\n<p>이렇게 여러 가지를 시도해 보다가 한 가지 원인을 알게 되었는데, React-Query가 제공하는 <a href=\"https://tanstack.com/query/v5/docs/react/guides/caching\">캐시 예제</a>에 있는 것과 동일합니다.</p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/8686d632-4fba-4dad-a303-d9ec16342890\" alt=\"image\"></p>\n<blockquote>\n<p>캐시의 시간이 완료되기 전에 똑같은 인스턴스가 마운트 된다면. 해당 쿼리는 즉시 사용 가능한 캐시 데이터를 반환하고, <code class=\"language-text\">queryFn</code>은 background에서 실행이 됩니다. 그리고 <strong>해당 fetch가 성공적으로 완료된다면, 방금 전에 fetch한 데이터가 캐시 데이터로 들어가는 것입니다.</strong></p>\n</blockquote>\n<p>즉, 저희가 겪었던 문제는 기본적으로 설정되어 있는 옵션들 (<code class=\"language-text\">staleTime:0, gcTime:5분</code>)에서는 자연스럽게 발생하는 문제들인 것이었습니다. 최초로 요청한 인스턴스가 가비지 콜렉션에 들어가기 전에 계속해서 같은 인스턴스를 요청하였고, 동작 원리에 따라 5분간은 같은 결과 (2 - 3 - 1 순서, 캐시 → fetch)로 작동하게 된 것이었습니다.</p>\n<p>결국에 이를 해결하기 위해서는 캐시 시간을 짧게 설정하면 되는 문제였고, 타임라인의 경우에는 캐시를 하지 않겠다는 의미로 <code class=\"language-text\">gcTime</code>을 0으로 설정하여 해결할 수 있는 문제였습니다.</p>\n<h3>결론</h3>\n<p>이번 트러블 슈팅을 하면서 크게 2가지 과정에서 문제가 있지 않았나 하는 생각이 들었습니다. </p>\n<p>첫 번째는 “잘 알지 못하는 라이브러리를 도입했다. 이 때문에 배포 당일 날에 문제를 마주했고, 쫄깃한 경험을 하게되었다.” 입니다. 물론 학습하는 입장에서 매우 좋은 경험이었지만, 실제 상황이었다면 살짝 아찔한 순간이었을 것 같습니다. </p>\n<p>두 번째는 이러한 문제를 개발 서버에서 확인했다는게 약간 치명적이지 않았나 라는 생각이 들었습니다. msw를 통해서 mockAPI를 통해서 모든 처리를 하고 있는데, 해당 API 통신에 대한 빡빡한 검증이 부족했던 것 같기도 하고, 테스트의 범위를 어디까지 정해야 하는 지도 살짝 애매한 느낌이 들긴 했습니다. 타임라인 이력을 불러오는 API을 구현한다면 잘 작성한 mockAPI이지만, e2e테스트로 생각을 한다면 살짝 부족한 과정이지 않았나를 생각하면서 e2e테스트의 중요성과 msw를 작성하는데 공식적으로 사용할만한 DB가 없었다는게 살짝 아쉬워 지는 트러블 슈팅이었습니다.</p>","frontmatter":{"title":"InfinityQuery에서 fetch가 제대로 이루어지지 않는다?!?!","date":"August 22, 2023","update":"August 22, 2023","tags":["Tanstack Query","Cache","useInfititeQuery"],"series":null},"fields":{"slug":"/tanstack-query-cache-trouble-shooting/","readingTime":{"minutes":8.065}}},"seriesList":{"edges":[{"node":{"id":"28f1d87e-d3fc-5567-8531-57649652864f","fields":{"slug":"/sprint-idea/"},"frontmatter":{"title":"구글 스프린트 기반 아이디어 도출"}}},{"node":{"id":"4a9246fb-171b-5973-88fc-864034e78afd","fields":{"slug":"/blog-starter/"},"frontmatter":{"title":"피움 블로그 생성과정"}}},{"node":{"id":"c826ce0e-1ea7-517c-8d19-84e90a59a798","fields":{"slug":"/jenkins-setting/"},"frontmatter":{"title":"젠킨스 설치하기"}}},{"node":{"id":"a387bf4f-567f-50e7-b6a7-99a1a1c8971b","fields":{"slug":"/jpa-notnull-nullable/"},"frontmatter":{"title":"@NotNull과 nullable = false는 어떤 차이가 있을까?"}}},{"node":{"id":"a78e224b-b711-5071-8e90-013d6f4bebc3","fields":{"slug":"/pium-deploy-step/"},"frontmatter":{"title":"피움의 배포과정"}}},{"node":{"id":"ce07fbab-1ed5-5f1e-8e2f-eb430879b56a","fields":{"slug":"/fe-tanstack-query/"},"frontmatter":{"title":"프론트엔드: Tanstack Query 사용에 대하여"}}},{"node":{"id":"159c943b-1a50-57dd-aa71-7557364752a5","fields":{"slug":"/ci-cd-setting/"},"frontmatter":{"title":"Jenkins와 Github Webhook을 이용해 CI/CD 구축하기"}}},{"node":{"id":"dea45a4a-bfde-5fbb-8a97-42d3a3e77a0b","fields":{"slug":"/jenkins-hook-by-label/"},"frontmatter":{"title":"PR 라벨로 젠킨스 빌드유발을 구분하기"}}},{"node":{"id":"1a03734e-d413-553f-9152-1dad2fc4acca","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"내 서버에 HTTPS 설정하기"}}},{"node":{"id":"cecbc8b9-db00-562b-aa0b-06c406cfc44a","fields":{"slug":"/bundle-analyze/"},"frontmatter":{"title":"bundle-analyze를 통한 bundle 크기 분석"}}},{"node":{"id":"707f8ffb-1409-5c27-b15a-5661b235c226","fields":{"slug":"/db-drop-stop/"},"frontmatter":{"title":"Table Drop 못하게 막아버리기"}}},{"node":{"id":"fe4b591a-4dd5-5dd2-b18a-b318afd1e9e3","fields":{"slug":"/transactional-not-in-restassured/"},"frontmatter":{"title":"[트러블슈팅] @SpringbootTest의 RANDOM_PORT 환경에서 @Transactional 어노테이션을 사용했을 때, RestAssured GET 요청이 수행되지 않는 경우(트랜잭션 격리 이해하기)"}}},{"node":{"id":"80aa708e-ef8a-5c79-9644-cb8c04d55a63","fields":{"slug":"/acceptance-test-resolve/"},"frontmatter":{"title":"인수테스트 데이터 초기화하기"}}},{"node":{"id":"15def1d5-c20f-5d07-b46e-24a14661365f","fields":{"slug":"/react-setting-without-cra/"},"frontmatter":{"title":"webpack으로만 React 설정하기 (without CRA)"}}},{"node":{"id":"66383c86-e2c8-533a-90e0-2effae572742","fields":{"slug":"/stylelint-and-husky/"},"frontmatter":{"title":"stylelint와 husky를 통해 컨벤션 통일하기"}}},{"node":{"id":"ed5951d5-beda-5a8f-adb2-07c2fcb38d5e","fields":{"slug":"/OAuth2.0/"},"frontmatter":{"title":"내가 이해한 OAuth2.0"}}},{"node":{"id":"45eeb9a3-557d-5704-8fd9-925283e1e27b","fields":{"slug":"/restdocs-start/"},"frontmatter":{"title":"RestDocs로 API 문서화하기"}}},{"node":{"id":"663b560a-734d-51a9-a6dc-3c4f50716c74","fields":{"slug":"/spring-event-apply/"},"frontmatter":{"title":"Spring Event 적용하기"}}},{"node":{"id":"55ae8038-3f65-5a59-8db3-c7405e7fc125","fields":{"slug":"/github-actions-cypress/"},"frontmatter":{"title":"피움 Cypress 자동화 구축기"}}},{"node":{"id":"503e9e71-eda3-53d7-8142-7c309faf213e","fields":{"slug":"/why_we_applied_querydsl/"},"frontmatter":{"title":"피움 서비스의 Querydsl 도입 이유"}}},{"node":{"id":"709124d0-5b05-5530-804d-e90ec9856a13","fields":{"slug":"/querydsl_apply_procedure/"},"frontmatter":{"title":"피움 서비스의 Querydsl 적용 과정"}}},{"node":{"id":"5c865dcb-cefd-58be-8968-b5edf6c8080c","fields":{"slug":"/server-logging/"},"frontmatter":{"title":"Logback을 이용해 운영 환경 별 로그 남기기"}}},{"node":{"id":"8269f166-d041-533c-9d44-332d8d8c3dca","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"CloudWatch를 이용한 모니터링 환경 구성"}}},{"node":{"id":"0faec7ad-3bd1-5f5e-9222-115f771df8ed","fields":{"slug":"/tanstack-query-cache-trouble-shooting/"},"frontmatter":{"title":"InfinityQuery에서 fetch가 제대로 이루어지지 않는다?!?!"}}},{"node":{"id":"c77f7199-7fc6-53a3-a1fb-0792e05655a7","fields":{"slug":"/OAuth2.0-backend/"},"frontmatter":{"title":"OAuth 2.0 로그인 구현하기 (카카오)"}}},{"node":{"id":"12e4480d-386b-5d0e-bd69-4209fed36066","fields":{"slug":"/OAuth-test-backend/"},"frontmatter":{"title":"외부 API 를 의존하는 OAuth 로그인 테스트하기"}}},{"node":{"id":"ff40e109-cc92-5d83-a213-ca9d07136d95","fields":{"slug":"/aws-s3-apply/"},"frontmatter":{"title":"AWS S3로 정적 이미지 배포하기"}}},{"node":{"id":"e343af80-72dd-5173-bbb5-5069a17d1200","fields":{"slug":"/search_in_spring_data_jpa/"},"frontmatter":{"title":"Spring Data Jpa를 활용한 검색 기능 개발하기"}}},{"node":{"id":"af344dd8-ea77-5fde-9452-a97952ce60be","fields":{"slug":"/submodule-apply/"},"frontmatter":{"title":"Git submodule을 이용한 민감정보 관리"}}},{"node":{"id":"08c9daf0-2344-52a9-8c68-31ac04c24ff0","fields":{"slug":"/tomcat-thread-config/"},"frontmatter":{"title":"톰캣 스레드 설정하기"}}},{"node":{"id":"eafed74f-ff11-5af1-a589-e9dd2ccb5c8e","fields":{"slug":"/http-cache/"},"frontmatter":{"title":"CloudFront와 HTTP 캐시"}}},{"node":{"id":"dbe47289-01f4-571d-9506-fbb92016f547","fields":{"slug":"/optimize-frontend/"},"frontmatter":{"title":"피움 최적화하기"}}},{"node":{"id":"7b830fe6-e2df-564a-926e-7f7800380336","fields":{"slug":"/query-analysis/"},"frontmatter":{"title":"서비스 내에서 발생하는 쿼리를 분석하고 개선하기"}}},{"node":{"id":"37437d15-a63e-52ef-b031-6ee1bc6fa8bc","fields":{"slug":"/image-resize/"},"frontmatter":{"title":"서버에서 이미지 리사이징하기"}}},{"node":{"id":"216f4636-4125-5765-83d8-a6a610692a41","fields":{"slug":"/dont-stop-deploy/"},"frontmatter":{"title":"무중단 배포 환경 구성하기"}}},{"node":{"id":"dd095976-5a96-51b5-9686-8956dc60cd24","fields":{"slug":"/hikaricp-connection-pool-setting/"},"frontmatter":{"title":"HikariCp Connection Pool 값 설정"}}},{"node":{"id":"625ad76f-acb1-56cc-9baa-3d6f1a954ac2","fields":{"slug":"/pwa/"},"frontmatter":{"title":"PWA를 도입해보자"}}},{"node":{"id":"6a12651c-e6b8-5fa6-9c57-766772d32680","fields":{"slug":"/serviceworker/"},"frontmatter":{"title":"Service Worker에 대한 대략적인 이해"}}}]},"previous":{"fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"CloudWatch를 이용한 모니터링 환경 구성"}},"next":{"fields":{"slug":"/OAuth2.0-backend/"},"frontmatter":{"title":"OAuth 2.0 로그인 구현하기 (카카오)"}}},"pageContext":{"id":"0faec7ad-3bd1-5f5e-9222-115f771df8ed","series":null,"previousPostId":"8269f166-d041-533c-9d44-332d8d8c3dca","nextPostId":"c77f7199-7fc6-53a3-a1fb-0792e05655a7"}},"staticQueryHashes":[],"slicesMap":{}}