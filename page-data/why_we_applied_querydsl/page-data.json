{"componentChunkName":"component---src-templates-post-jsx","path":"/why_we_applied_querydsl/","result":{"data":{"site":{"siteMetadata":{"title":"pium.log"}},"markdownRemark":{"id":"503e9e71-eda3-53d7-8142-7c309faf213e","excerpt":"이 글은 우테코 피움팀 크루 '하마드'가 작성했습니다. 개요 우아한테크코스 5기 피움 프로젝트를 진행하면서, 필터링 기능을 구현하기 위해 Querydsl 라이브러리를 도입한 과정을 정리한다. 문제상황 필터링 기능 도입 내가 담당한 파트는 아래와 같다. \"사용자가 보유한 반려 식물의 관리 이력을 최신 순으로 조회하기\"   은  라는 테이블 및 엔티티 객체에…","html":"<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/d2ddb0dd0d47e03920aa2bc404809831/8283d/querydsl.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 41.1764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABKUlEQVR42nVR3UrDMBTuy/gWvo3gU3jhMwwEUUTFC5GhN1O80U2YZThkdRez2dStLt1st7a2S0ObJm1M1xY7fz5Ccjg5X77vnEgsjpMCfImkhDyzXMXtdyzFgsxXaPwvTFG0dfdRac/7dsiLtyShK/imaeq67mMs4gkcj7XhVIcvfSDyyPscWWjjEtYGnmqF1Wd3sqCZBUkchBBZluv1hqJ0VQDOa9e7x2e3zdZN86HV7hijwYliHjw5aSVLcBQbiGXiqe3cME8oZZyxC4BOe4vKo7ctu1WAMeUNDe11bFG2r1ibVzCLk6LnlYahG7055N0lvVmguWTohAGND7v2PfSdgK3tqOtHr6WB/TOkMgQfWKHhUzG5Oaa5MvtFFk7SDyjvafKnQML5F9cIwXufNsrWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='querydsl' title='' src='/static/d2ddb0dd0d47e03920aa2bc404809831/ca1dc/querydsl.png' srcset='/static/d2ddb0dd0d47e03920aa2bc404809831/e7570/querydsl.png 170w,\n/static/d2ddb0dd0d47e03920aa2bc404809831/f46e7/querydsl.png 340w,\n/static/d2ddb0dd0d47e03920aa2bc404809831/ca1dc/querydsl.png 680w,\n/static/d2ddb0dd0d47e03920aa2bc404809831/02d09/querydsl.png 1020w,\n/static/d2ddb0dd0d47e03920aa2bc404809831/8283d/querydsl.png 1162w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<blockquote>\n<p>이 글은 우테코 피움팀 크루 '<a href=\"https://github.com/rawfishthelgh\">하마드</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>개요</h2>\n<hr>\n<p>우아한테크코스 5기 피움 프로젝트를 진행하면서, 필터링 기능을 구현하기 위해 Querydsl 라이브러리를 도입한 과정을 정리한다.</p>\n<h2>문제상황</h2>\n<hr>\n<h3>필터링 기능 도입</h3>\n<p>내가 담당한 파트는 아래와 같다.</p>\n<blockquote>\n<p>\"사용자가 보유한 반려 식물의 관리 이력을 최신 순으로 조회하기\" </p>\n</blockquote>\n<p><code class=\"language-text\">반려 식물의 관리 이력</code> 은 <code class=\"language-text\">History</code> 라는 테이블 및 엔티티 객체에 저장되고 관리된다.</p>\n<p><code class=\"language-text\">History</code> 객체 및 테이블 형태는 아래와 같이 생겨먹었다.</p>\n<p><strong>History 객체</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@Table</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"history\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@NoArgsConstructor</span><span class=\"token punctuation\">(</span>access <span class=\"token operator\">=</span> <span class=\"token class-name\">AccessLevel</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROTECTED</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">History</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BaseEntity</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">IDENTITY</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token annotation punctuation\">@ManyToOne</span><span class=\"token punctuation\">(</span>fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">LAZY</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"pet_plant_id\"</span><span class=\"token punctuation\">,</span> nullable <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">PetPlant</span> petPlant<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"event_date\"</span><span class=\"token punctuation\">,</span> nullable <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LocalDate</span> date<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token annotation punctuation\">@ManyToOne</span><span class=\"token punctuation\">(</span>fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">LAZY</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"history_category_id\"</span><span class=\"token punctuation\">,</span> nullable <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">HistoryCategory</span> historyCategory<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Valid</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token annotation punctuation\">@Embedded</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">HistoryContent</span> historyContent<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p><strong>history 테이블</strong>\n<img src=\"https://velog.velcdn.com/images/rg970604/post/c71da5e7-4a11-4ced-84d9-4d81764abd29/image.png\"></p>\n<p>기존에는 기록의 카테고리에 상관없이 전체를 불러와 조회를 하는 형태였지만, 피움 서비스는 4차 스프린트 과정에서 </p>\n<blockquote>\n<p>원하는 카테고리(historyCategory) 조합에 따라서 해당 카테고리들에 해당하는 관리 기록(History)들만 조회해 온다</p>\n</blockquote>\n<p>라는 기능을 추가하게 되었다.</p>\n<p><code class=\"language-text\">/history?petPlantId=1&amp;page=0&amp;size=20&amp;filter=”lastwaterDate,flowerpot…”</code>\n위 url의 쿼리 파라미터 중 filter에 해당하는 값들을 기준으로 필터링을 수행하는 것이다.</p>\n<h3>어떤 필터링 조건이냐에 따라 쿼리 형태가 어마무시하게 변화한다.</h3>\n<p><code class=\"language-text\">History</code> 의 카테고리 목록은</p>\n<p><code class=\"language-text\">location, flowerpot, waterCycle, light, wind, lastWaterDate</code></p>\n<p>총 여섯 가지를 보유하고 있다.</p>\n<p>이 카테고리를 활용한 필터링이 전혀 들어오지 않을 수도(0개), 모두 들어올수도(6개), 몇 개만 들어올 수도 있다(1~5개).</p>\n<p>또한 개수가 같아도, 어떤 카테고리가 조합되느냐에 따라 쿼리 형태가 변화한다.</p>\n<p>예를 들면 </p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">// 필터링 조건이 location, flowerpot인 경우</span>\n<span class=\"token keyword\">where</span> history<span class=\"token punctuation\">.</span>pet_plant_id <span class=\"token operator\">=</span> 반려식물ID \n        <span class=\"token operator\">and</span> history_category<span class=\"token punctuation\">.</span>history_type <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span>flowerpot<span class=\"token punctuation\">)</span>\n        \n<span class=\"token comment\">// 필터링 조건이 flowerpot, waterCycle인 경우</span>\n<span class=\"token keyword\">where</span> history<span class=\"token punctuation\">.</span>pet_plant_id <span class=\"token operator\">=</span> 반려식물ID\n        <span class=\"token operator\">and</span> history_category<span class=\"token punctuation\">.</span>history_type <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span>flowerpot<span class=\"token punctuation\">,</span>waterCycle<span class=\"token punctuation\">)</span>\n        \n<span class=\"token comment\">// 어쩌구저쩌구 수많은 경우</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>따라서, 계산해 봤을 때 </p>\n<blockquote>\n<p>6C0 + 6C1 + 6C2 + 6C3 + 6C4 + 6C5  + 6C6\n= 1 + 6 + 15 + 20 + 15 + 6 + 1\n= 64</p>\n</blockquote>\n<p>총 64개의 경우의 수가 등장하게 된다 ;;</p>\n<p>따라서 현재 이 문제를 쌩으로 해결하려면, 조합에 따라 총64개의 분기문을 작성해야 한다...</p>\n<p>그런데 64개의 분기문을 작성하면 만들고 끝이 아니라, 필터링 조건이 하나만 늘어나도 엄청난 양의 분기문의 추가와 수정이 일어난다. 이럴 바엔 그냥 개발자를 그만 두는게 나을 수도 있다.</p>\n<p>따라서! 피움은 동적 쿼리를 쉽게 해결할 수 있는 도구를 선택 및 도입하기로 했다.</p>\n<h2>대안분석 및 선택과정</h2>\n<hr>\n<p>java / spring에서 동적 쿼리를 해결하는 도구는 여럿 존재한다. 우리가 어떤 대안을 떠올렸는지와, 이를 도입하지 않은/도입한 이유를 간단하게 정리하면 아래와 같다.</p>\n<h3><strong>Mybatis</strong></h3>\n<p>JdbcTemplate의 동적 쿼리 한계를 효율적으로 해결하기 위해 등장한 SQL Mapper 프레임워크이다. 하지만 우리는 SQL Mapper가 아닌 JPA라는 ORM을 사용하기에 navite한 sql 쿼리를 직접 작성하지 않으므로 도입하지 않았다.</p>\n<h3><strong>JPA - Criteria Query</strong></h3>\n<p>JPA에서는 JPQL이라는 쿼리 기술을 사용하여 엔티티 객체를 대상으로 질의할 수 있는 기능을 제공한다. 그러나 JPQL도 sql mapper 처럼 String 형태로 작성하므로 컴파일 단계에서 오류를 잡아내기 힘든데, Criteria Query 클래스를 사용하면 자바 코드로 JPQL을 작성할 수 있어 타입 안전성을 제공한다. 또한 조건문을 활용하여 동적 쿼리를 처리할 수 있는 기능을 제공한다. 그럼 이 방법론을 써야겠다는 생각이 슬슬 들게 된다.</p>\n<p>그러나...Criteria Query에 대한 레퍼런스를 찾아보니, 대부분의 대답은 이러했다.</p>\n<blockquote>\n<p>쓰지 마세요 가독성 안좋습니다...</p>\n</blockquote>\n<p>그래서 이게 어떤 형태를 갖는지 대충 찾아봤다. gpt 선생님에게\n<code class=\"language-text\">where history.pet_plant_id = 반려식물ID \n        and history_category.history_type in (타입 조건들...)</code>\n코드 작성을 요청드리니 다음과 같은 코드 형태가 태어났다. 아래 코드는 그냥 Criteria Query가 이런 형태를 갖는구나 정도로 생각하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DynamicCriteriaQueryExample</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">EntityManager</span> entityManager <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// EntityManager 생성 코드</span>\n\n        <span class=\"token class-name\">CriteriaBuilder</span> criteriaBuilder <span class=\"token operator\">=</span> entityManager<span class=\"token punctuation\">.</span><span class=\"token function\">getCriteriaBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Criteria Query 생성</span>\n        <span class=\"token class-name\">CriteriaQuery</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">History</span><span class=\"token punctuation\">></span></span> criteriaQuery <span class=\"token operator\">=</span> criteriaBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">History</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Root</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">History</span><span class=\"token punctuation\">></span></span> historyRoot <span class=\"token operator\">=</span> criteriaQuery<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">History</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 동적으로 생성되는 조건을 위한 리스트 생성</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Predicate</span><span class=\"token punctuation\">></span></span> predicates <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 동적 조건 추가</span>\n        <span class=\"token keyword\">int</span> plantId <span class=\"token operator\">=</span> 반려식물<span class=\"token constant\">ID</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 동적으로 설정되는 값</span>\n        predicates<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>criteriaBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>historyRoot<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"petPlantId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> plantId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> types <span class=\"token operator\">=</span>히스토리 타입들<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 동적으로 설정되는 값</span>\n        predicates<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>historyRoot<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"historyType\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">in</span><span class=\"token punctuation\">(</span>types<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 모든 동적 조건을 AND로 결합</span>\n        criteriaQuery<span class=\"token punctuation\">.</span><span class=\"token function\">where</span><span class=\"token punctuation\">(</span>predicates<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Predicate</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 결과 쿼리 실행</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">History</span><span class=\"token punctuation\">></span></span> resultList <span class=\"token operator\">=</span> entityManager<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>criteriaQuery<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResultList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 결과 처리 등의 로직</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>딱 봐도 뭔가 코드가 더럽고, 어떤 sql이 탄생하는지 유추가 정말 힘들다. 위 코드를 보고 주석의 상세한 설명 없이 동적 where in 절이 탄생하는게 유추되는가? 코드 형태가 sql이 아닌 객체 중심적이다보니 발생한 문제이다.</p>\n<h3><strong>Querydsl</strong></h3>\n<p>자바 코드로 jpql을 생성할 수 있는 Criteria Query의 이점을 유지하면서, sql과 비슷한 형태로 코드를 작성할 수 있는 장점까지 챙겨간 오픈소스 라이브러리다.</p>\n<p>따라서 피움은 </p>\n<blockquote>\n<ol>\n<li>가독성 : sql과 비슷한 형태의 자바 코드 작성</li>\n<li>타입 안전성 : 자바 코드로 작성해 컴파일 단계에서 오류 파악 가능</li>\n<li>생산성 : join, 서브쿼리, 집계함수 등 해당 서비스에서 필요한 복잡한 쿼리 형태를 간단하게 작성 가능한 api 제공</li>\n<li>유지보수성 : 현재 사용하고 있는 라이브러리, 프레임워크를 변경하지 않고 개발 가능</li>\n</ol>\n</blockquote>\n<p>동적 쿼리를 구현하는 과정에서, 다른 대안에 비해 위 네 가지의 가치를 창출할 수 있다는 결론을 내리고 Querydsl을 도입했다.</p>\n<p>다음 포스팅에서는 Querydsl 라이브러리를 우리 서비스에 어떤 형태로 적용했는지 구현 과정을 설명하도록 하겠다.</p>","frontmatter":{"title":"피움 서비스의 Querydsl 도입 이유","date":"August 14, 2023","update":"August 14, 2023","tags":["Querydsl"],"series":null},"fields":{"slug":"/why_we_applied_querydsl/","readingTime":{"minutes":8.645}}},"seriesList":{"edges":[{"node":{"id":"28f1d87e-d3fc-5567-8531-57649652864f","fields":{"slug":"/sprint-idea/"},"frontmatter":{"title":"구글 스프린트 기반 아이디어 도출"}}},{"node":{"id":"4a9246fb-171b-5973-88fc-864034e78afd","fields":{"slug":"/blog-starter/"},"frontmatter":{"title":"피움 블로그 생성과정"}}},{"node":{"id":"c826ce0e-1ea7-517c-8d19-84e90a59a798","fields":{"slug":"/jenkins-setting/"},"frontmatter":{"title":"젠킨스 설치하기"}}},{"node":{"id":"a387bf4f-567f-50e7-b6a7-99a1a1c8971b","fields":{"slug":"/jpa-notnull-nullable/"},"frontmatter":{"title":"@NotNull과 nullable = false는 어떤 차이가 있을까?"}}},{"node":{"id":"a78e224b-b711-5071-8e90-013d6f4bebc3","fields":{"slug":"/pium-deploy-step/"},"frontmatter":{"title":"피움의 배포과정"}}},{"node":{"id":"ce07fbab-1ed5-5f1e-8e2f-eb430879b56a","fields":{"slug":"/fe-tanstack-query/"},"frontmatter":{"title":"프론트엔드: Tanstack Query 사용에 대하여"}}},{"node":{"id":"159c943b-1a50-57dd-aa71-7557364752a5","fields":{"slug":"/ci-cd-setting/"},"frontmatter":{"title":"Jenkins와 Github Webhook을 이용해 CI/CD 구축하기"}}},{"node":{"id":"dea45a4a-bfde-5fbb-8a97-42d3a3e77a0b","fields":{"slug":"/jenkins-hook-by-label/"},"frontmatter":{"title":"PR 라벨로 젠킨스 빌드유발을 구분하기"}}},{"node":{"id":"1a03734e-d413-553f-9152-1dad2fc4acca","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"내 서버에 HTTPS 설정하기"}}},{"node":{"id":"cecbc8b9-db00-562b-aa0b-06c406cfc44a","fields":{"slug":"/bundle-analyze/"},"frontmatter":{"title":"bundle-analyze를 통한 bundle 크기 분석"}}},{"node":{"id":"707f8ffb-1409-5c27-b15a-5661b235c226","fields":{"slug":"/db-drop-stop/"},"frontmatter":{"title":"Table Drop 못하게 막아버리기"}}},{"node":{"id":"fe4b591a-4dd5-5dd2-b18a-b318afd1e9e3","fields":{"slug":"/transactional-not-in-restassured/"},"frontmatter":{"title":"[트러블슈팅] @SpringbootTest의 RANDOM_PORT 환경에서 @Transactional 어노테이션을 사용했을 때, RestAssured GET 요청이 수행되지 않는 경우(트랜잭션 격리 이해하기)"}}},{"node":{"id":"80aa708e-ef8a-5c79-9644-cb8c04d55a63","fields":{"slug":"/acceptance-test-resolve/"},"frontmatter":{"title":"인수테스트 데이터 초기화하기"}}},{"node":{"id":"15def1d5-c20f-5d07-b46e-24a14661365f","fields":{"slug":"/react-setting-without-cra/"},"frontmatter":{"title":"webpack으로만 React 설정하기 (without CRA)"}}},{"node":{"id":"66383c86-e2c8-533a-90e0-2effae572742","fields":{"slug":"/stylelint-and-husky/"},"frontmatter":{"title":"stylelint와 husky를 통해 컨벤션 통일하기"}}},{"node":{"id":"ed5951d5-beda-5a8f-adb2-07c2fcb38d5e","fields":{"slug":"/OAuth2.0/"},"frontmatter":{"title":"내가 이해한 OAuth2.0"}}},{"node":{"id":"45eeb9a3-557d-5704-8fd9-925283e1e27b","fields":{"slug":"/restdocs-start/"},"frontmatter":{"title":"RestDocs로 API 문서화하기"}}},{"node":{"id":"663b560a-734d-51a9-a6dc-3c4f50716c74","fields":{"slug":"/spring-event-apply/"},"frontmatter":{"title":"Spring Event 적용하기"}}},{"node":{"id":"55ae8038-3f65-5a59-8db3-c7405e7fc125","fields":{"slug":"/github-actions-cypress/"},"frontmatter":{"title":"피움 Cypress 자동화 구축기"}}},{"node":{"id":"503e9e71-eda3-53d7-8142-7c309faf213e","fields":{"slug":"/why_we_applied_querydsl/"},"frontmatter":{"title":"피움 서비스의 Querydsl 도입 이유"}}},{"node":{"id":"709124d0-5b05-5530-804d-e90ec9856a13","fields":{"slug":"/querydsl_apply_procedure/"},"frontmatter":{"title":"피움 서비스의 Querydsl 적용 과정"}}},{"node":{"id":"5c865dcb-cefd-58be-8968-b5edf6c8080c","fields":{"slug":"/server-logging/"},"frontmatter":{"title":"Logback을 이용해 운영 환경 별 로그 남기기"}}},{"node":{"id":"8269f166-d041-533c-9d44-332d8d8c3dca","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"CloudWatch를 이용한 모니터링 환경 구성"}}},{"node":{"id":"0faec7ad-3bd1-5f5e-9222-115f771df8ed","fields":{"slug":"/tanstack-query-cache-trouble-shooting/"},"frontmatter":{"title":"InfinityQuery에서 fetch가 제대로 이루어지지 않는다?!?!"}}},{"node":{"id":"c77f7199-7fc6-53a3-a1fb-0792e05655a7","fields":{"slug":"/OAuth2.0-backend/"},"frontmatter":{"title":"OAuth 2.0 로그인 구현하기 (카카오)"}}},{"node":{"id":"12e4480d-386b-5d0e-bd69-4209fed36066","fields":{"slug":"/OAuth-test-backend/"},"frontmatter":{"title":"외부 API 를 의존하는 OAuth 로그인 테스트하기"}}},{"node":{"id":"ff40e109-cc92-5d83-a213-ca9d07136d95","fields":{"slug":"/aws-s3-apply/"},"frontmatter":{"title":"AWS S3로 정적 이미지 배포하기"}}},{"node":{"id":"e343af80-72dd-5173-bbb5-5069a17d1200","fields":{"slug":"/search_in_spring_data_jpa/"},"frontmatter":{"title":"Spring Data Jpa를 활용한 검색 기능 개발하기"}}},{"node":{"id":"af344dd8-ea77-5fde-9452-a97952ce60be","fields":{"slug":"/submodule-apply/"},"frontmatter":{"title":"Git submodule을 이용한 민감정보 관리"}}},{"node":{"id":"08c9daf0-2344-52a9-8c68-31ac04c24ff0","fields":{"slug":"/tomcat-thread-config/"},"frontmatter":{"title":"톰캣 스레드 설정하기"}}},{"node":{"id":"7b830fe6-e2df-564a-926e-7f7800380336","fields":{"slug":"/query-analysis/"},"frontmatter":{"title":"서비스 내에서 발생하는 쿼리를 분석하고 개선하기"}}}]},"previous":{"fields":{"slug":"/github-actions-cypress/"},"frontmatter":{"title":"피움 Cypress 자동화 구축기"}},"next":{"fields":{"slug":"/querydsl_apply_procedure/"},"frontmatter":{"title":"피움 서비스의 Querydsl 적용 과정"}}},"pageContext":{"id":"503e9e71-eda3-53d7-8142-7c309faf213e","series":null,"previousPostId":"55ae8038-3f65-5a59-8db3-c7405e7fc125","nextPostId":"709124d0-5b05-5530-804d-e90ec9856a13"}},"staticQueryHashes":[],"slicesMap":{}}