{"componentChunkName":"component---src-templates-post-jsx","path":"/serviceworker/","result":{"data":{"site":{"siteMetadata":{"title":"pium.log"}},"markdownRemark":{"id":"6a12651c-e6b8-5fa6-9c57-766772d32680","excerpt":"이 글은 우테코 피움팀 크루 '클린'가 작성했습니다. Service Worker 서비스 워커는 웹 어플리케이션과 브라우저, 네트워크 사이에 위치한 프록시 서버 역할을 하고 있습니다. 서비스 워커의 주 목적은 효과적인 오프라인 경험을 만드는 것입니다. 서비스 워커는 보안이 중요하기 때문에 로컬 호스트를 제외한다면 https 통신이 가능한 상태에서만 동작합니…","html":"<blockquote>\n<p>이 글은 우테코 피움팀 크루 '<a href=\"https://github.com/hozzijeong\">클린</a>'가 작성했습니다.</p>\n</blockquote>\n<h1>Service Worker</h1>\n<p>서비스 워커는 웹 어플리케이션과 브라우저, 네트워크 사이에 위치한 프록시 서버 역할을 하고 있습니다. 서비스 워커의 주 목적은 <strong>효과적인 오프라인 경험을 만드는 것입니다.</strong> 서비스 워커는 보안이 중요하기 때문에 로컬 호스트를 제외한다면 https 통신이 가능한 상태에서만 동작합니다.</p>\n<p>서비스 워커는 웹과는 다른 독립적인 환경 레이어에서 동작하기 때문에 DOM객체나 window 객체에 접근 할 수 없습니다. 또한 캐시 저장소를 통해 저장된 리소스 사용이 가능합니다. 이에 따라 일부 기능에는 제한이 있지만 어느정도 동작 구현이 가능합니다.</p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/b9a3d7b6-4c0f-48c8-b560-cb2df95cbdde\" alt=\"image\"></p>\n<blockquote>\n<p>사용자가 오프라인 상태일 때를 포함하여 앱이 서비스 워커 범위에 포함되는 리소스를 요청하면 서비스 워커가 네트워크 프록시 역할을 하여 요청을 가로챕니다. 그런 다음, 일반적으로 서비스 워커가 없는 경우와 마찬가지로 Cache Storage API를 통해 캐시로부터 리소스를 제공할지, 아니면 로컬 알고리즘에서 리소스를 생성할지 결정할 수 있습니다. 이를 통해 플랫폼 앱에서 제공하는 것과 유사한 환경을 제공할 수 있으며 완전히 오프라인으로 작동할 수도 있습니다. - <a href=\"https://web.dev/learn/pwa/service-workers?hl=ko\">web.dev</a></p>\n</blockquote>\n<h2>범위</h2>\n<p>서비스 워커의 범위는 폴더에 따라 결정됩니다. 만약 <code class=\"language-text\">example.com/pwa/sw.js</code>에 있는 서비스 워커는 pwa 경로 이하에 있는 모든 탐색에 대해 프록시 제어를 하고 있습니다. 또한 범위당 하나의 서비스 워커만을 제공하고 있기 때문에 활성화 및 실행중인 탭에 관계 없이 하나의 인스턴스만 사용 가능합니다. <em>위와 같은 특성때문에 PWA와 관련된 모든 요청을 가로챌수 있도록 서비스 워커의 범위는 앱 루트에 최대한 가깝게 설정하는 것이 좋습니다.</em> </p>\n<h2>등록</h2>\n<p>서비스 워커를 등록하기 전에 우선 서비스를 PWA에 먼저 등록해야 합니다. 만약 PWA에 처음 방문한 것이라면 네트워크 요청을 서비스 워커가 아닌 실제 서버와 합니다.</p>\n<p>Service Worker API를 사용하는지를 먼저 확인한 다음에 등록을 할 수 있습니다. 모든 브라우저에서 Service Worker API를 제공하는 것이 아니기 때문에 필요한 조치입니다.</p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/3de583c8-b631-4728-8c4c-0a8f3a0ca8f0\" alt=\"스크린샷 2023-10-31 오전 10 45 49\"></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'serviceWorker'</span> <span class=\"token keyword\">in</span> navigator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   navigator<span class=\"token punctuation\">.</span>serviceWorker<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/serviceworker.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Service Worker API를 통해 서비스 워커를 등록한다면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope\">ServiceWorkerGlobalScope</a>가 형성이 됩니다. 이것은 기본적으로 DOM 없이도 main script execution thread를 실행할 수 있는 작업자입니다.</p>\n<h2>생명 주기</h2>\n<p>서비스 워커의 생명주기는 브라우저와는 다르게 동작합니다. 그렇기 때문에 브라우저가 닫혀도 백그라운드에서 데이터를 다운 받을 수 있고 푸시 알림을 전송받을 수 있습니다. 즉, 사용자가 같은 브라우저로 재접속 해도 이전에 사용하던 서비스 워커는 그대로 존재합니다. </p>\n<p>브라우저가 닫혀 있는 상태에서도 서비스 워커는 계속해서 돌아간다면 과연 그 리소스 낭비는 어떻게 관리할까요? 서비스 워커는 사용하지 않을때는 잠시 중지되어 있습니다. 잠시 중지되어 있다가 요청이 들어온다면 그 때 잠에서 깬 다음 자신이 할 일을 하는 것 뿐입니다. </p>\n<p>그렇다면 서비스 워커의 생명 주기에 대해서 한번 알아보겠습니다.</p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/444785ef-3b69-4426-8a1d-3768a7f195be\" alt=\"image\"></p>\n<h3>Installing</h3>\n<p>서비스 워커를 <code class=\"language-text\">register</code>할 때 설정한 ServiceWorker 파일은 이제 본격적으로 서비스 워커를 설치합니다. 여기서 <code class=\"language-text\">install</code>이벤트를 통해 설치하게 되는데, 이 이벤트는 서비스 워커가 받는 첫 번째 이벤트이면서 단 한번만 발생합니다. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// serviceworker.js</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"install\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\tevent<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span>\n    caches<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>assetCacheName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      cache<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n        <span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>여기서 self는 <code class=\"language-text\">register</code>할 때 생성된 <code class=\"language-text\">ServiceWorkerGlobalScope</code>를 의미합니다.</p>\n</blockquote>\n<p><code class=\"language-text\">waitUntill</code>이라는 메서드는 프라미스 형태로, 설치 성공 또는 실패를 나타냅니다. 해당 값이 반환되기 전까지는 서비스 워커는 설치되지 않습니다. 만약에 <code class=\"language-text\">waitUntill</code>이 거절되게 된다면 설치는 실패하게 되고 그 뒤로는 아무것도 할 수 없게됩니다. </p>\n<h3>Installed/waiting</h3>\n<p>성공적으로 <code class=\"language-text\">install</code>됐다면 설치된 상태로 진입됩니다. 다른 서비스 워커가 이 앱을 제어하지 않는한 즉시 activating 상태로 변경됩니다. </p>\n<p>waiting 상태는 서비스 워커 업데이트 에서 주로 다루게 됩니다.</p>\n<h3>Activating</h3>\n<p>서비스 워커가 클라이언트를 제어할 수 있고, <code class=\"language-text\">push</code> 및 <code class=\"language-text\">sync</code> 등 서비스 워커의 기능을 할 수 있는 함수 이벤트를 처리할 준비가 된다면 <code class=\"language-text\">activate</code>이벤트가 발생됩니다.  <code class=\"language-text\">activate</code>이벤트에서는 현재 활성화 된 캐시에서 필요 없는 캐시들은 지울 필요가 있습니다. (현재 활성화 된 기준을 보기 위해서는 결국 서비스 워커에 버저닝이 필요한 것을 알 수 있습니다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> assetCacheName <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">assets-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>version<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'activate'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span>\n    caches<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cacheNames</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>\n        cacheNames<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cacheName</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cacheName <span class=\"token operator\">!==</span> assetCacheName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>cacheName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 활성화 즉시 클라이언트를 제어한다.(새로고침 불필요)</span>\n  self<span class=\"token punctuation\">.</span>clients<span class=\"token punctuation\">.</span><span class=\"token function\">claim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<aside>\n💡 서비스 워커가 처음 등록될 때 페이지는 다음 로드까지 사용이 되지 않는데, `clients.claim()`메서드를 사용하게 된다면 클라이언트를 즉시 제어할 수 있도록 합니다.\n</aside>\n<p><code class=\"language-text\">activate</code>이벤트는 활성화 되기 전에 처리가 되고 있으므로 <code class=\"language-text\">waitUntill</code> 함수를 통해서 해당 서비스 워커가 제대로 동작하기 전에 사전 작업을 할 수 있습니다. 이제 <code class=\"language-text\">waituntill</code>함수가 성공한다면 activated로 넘어가게 됩니다.</p>\n<h3>Activated</h3>\n<p>활성화가 되고 난 다음에는 페이지 제어와 <code class=\"language-text\">fetch</code>, <code class=\"language-text\">push</code>, <code class=\"language-text\">sync</code>와 같은 기능 이벤트 사용이 가능합니다. 서비스 워커는 페이지 로드가 되기 전에만 페이지 제어가 가능합니다. 즉, 서비스 워커가 활성화되기 전에 로드가 시작된 페이지는 제어할 수 없습니다. (항상 뒤에서만 움직이는 다크나이트 같은 존재랄까…?)</p>\n<aside>\n💡 **서비스 워커가 로드가 시작된 후에 페이지를 제어할 수 없는 이유**\n비디오 파일 로드가 너무 오래걸려서, 미리 비디오가 호스팅 된 서버에서 링크를 제공하도록 하는 app-sw.js가 있다고 가정을 해봅시다. 이 서비스 워커는 모든 비디오 요청을 가로채고, 비디오나 미러 사이트 링크를 포함하는 JSON 파일 중 하나를 반환합니다. app-sw.js는 비디오에 대한 요청 처리나 미러 사이트에 대한 요청처리 둘 모두를 알고 있습니다. \n하지만, 페이지가 로드된 다음에 app.js에서 똑같이 비디오를 받는다는 가정을 했을 때 만약에 app-sw.js에서 이 통신을 가로채서 값을 받아버린다 면 app.js는 이 요청이 미러 사이트에 대한 요청인지 원래 비디오 파일들을 요청한 것인지에 대해 알 수 가 없습니다. **따라서 서비스 워커는 로드가 시작된 후에 페이지를 제어할 수 없습니다.**\n</aside>\n<h3>Redundant</h3>\n<p>서비스 워커 등록 혹은 설치중에 실패한 경우나 좀 더 최신버전으로 대체된 서비스 워커는 이 상태로 이동하게 됩니다. 이 상태의 서비스 워커는 더 이상 앱에 영향을 주지 않습니다.</p>\n<h3>서비스 워커의 생명주기와 waitUntill</h3>\n<p>해당 메서드는 promise를 콜백으로 받습니다. 제일 처음에 서비스 워커는 항상 깨어있는 것이 아니라고 했습니다. 따로 등록한 이벤트들이 발생했을 때 잠깐 깨어났다가 해당 이벤트가 종료됨과 동시에 같이 잠들게 됩니다. 그렇다면 다음과 같은 경우에는 어떻게 될까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">self<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"push\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/mutate\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>registeration<span class=\"token punctuation\">.</span><span class=\"token function\">showNotification</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">push</code> 이벤트가 발생했을 때 <code class=\"language-text\">mutate</code>에서 데이터를 받아서 해당 값을 <code class=\"language-text\">notification</code>하는 코드 입니다. 하지만 이 코드에는 아주 치명적인 문제가 있습니다. 바로 <code class=\"language-text\">fetch</code>를 시작함과 동시에  이벤트 콜백이 종료됩니다. 즉, 로 받아온 데이터를 처리하지 않고 바로 끝나버리는 문제가 발생합니다. </p>\n<p>이 문제를 해결하기 위해서 사용하는 것이 <code class=\"language-text\">waitUntill</code> 입니다. 서비스 워커의 실행 수명? 은 이벤트 리스너와 관련이 있습니다.  메서드를 통해서 해당 메서드의 콜백이 반환하는 <code class=\"language-text\">promise</code>가 <code class=\"language-text\">pending</code>이 아닐때까지 계속해서 이벤트 리스너 콜백 함수를 기다릴 수 있습니다. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">self<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"push\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\tevent<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntill</span><span class=\"token punctuation\">(</span>\n\t\t  <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/mutate\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t\t    <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>registeration<span class=\"token punctuation\">.</span><span class=\"token function\">showNotification</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>서비스 워커 업데이트</h3>\n<p>위에서 얘기한 것 처럼 서비스 워커의 실행 코드가 달라질 수 있습니다. 하지만 브라우저를 종료한다고 해서 서비스 워커가 종료되지는 않습니다. 그렇다면 어떻게 바뀐 서비스 워커의 내용을 업데이트 해야할 까요?</p>\n<p>서비스 워커 업데이트는 다음 중 하나라도 발생하면 업데이트가 트리거 됩니다.</p>\n<ul>\n<li>A navigation to an in-scope page.</li>\n<li>24시간 내에 업데이트 확인이 없는 푸시 및 동기화 이벤트</li>\n<li>서비스 워커 URL이 변경되었을 때 <code class=\"language-text\">register</code>메서드가 호출되었을 경우. (<a href=\"https://web.dev/articles/service-worker-lifecycle#avoid-url-change\">하지만 이 경우는 피해야 합니다</a>)</li>\n</ul>\n<p>대부분의 브라우저들은 서비스 워커 스크립트 업데이트를 확인할 때 캐싱 헤더를 무시합니다. 반면 <code class=\"language-text\">importScripts</code>를 통해 리소스를 가져올 때는 캐싱 헤더를 고려하고 있습니다. 서비스 워커는 브라우저에 이미 있는 것 과 바이트가 다르면 업데이트된 것으로 간주하는데, 업데이트된 서비스 워커는 기존 워커와 함께 시작되며 자체 <code class=\"language-text\">install</code>이벤트를 가져옵니다. 만약 업데이트 된 서비스 워커에 문제가 있다면 기존 작업자가 유지됩니다. </p>\n<p>설치가 정상적으로 완료된다면 기존에 있던 서비스 워커가 0개의 클라이언트를 제어할 때까지 업데이트된 서비스 워커는 <code class=\"language-text\">wait</code>(대기)상태에 있습니다. (0개의 클라이언트 제어란, 현재 구동중인 서비스 워커의 업데이트를 모든 페이지에 대해서 트리거가 발생한다면 대기중인 서비스 워커가 실행됩니다.) 하지만 <code class=\"language-text\">self.skipWaiting()</code>이라는 메서드를 사용하게 된다면 이 wait 상태를 방지하고 설치가 완료되는 즉시 서비스 워커가 활성화 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">self<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"install\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\tself<span class=\"token punctuation\">.</span><span class=\"token function\">skipWaiting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>개발하는 입장에서는 다음과 같은 옵션들을 통해서 서비스 워커 즉시 활성화가 가능합니다. </p>\n<p><img src=\"https://github.com/pium-official/pium-official.github.io/assets/50974359/069073db-e1f0-494c-a636-ebf91fdb5800\" alt=\"스크린샷 2023-10-31 오후 2 22 18\"></p>\n<hr>\n<h3>참조</h3>\n<p><a href=\"https://web.dev/articles/service-worker-lifecycle?hl=ko#clientsclaim\">https://web.dev/articles/service-worker-lifecycle?hl=ko#clientsclaim</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope\">https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope</a></p>\n<p><a href=\"https://www.oreilly.com/library/view/building-progressive-web/9781491961643/ch04.html\">https://www.oreilly.com/library/view/building-progressive-web/9781491961643/ch04.html</a></p>\n<p><a href=\"https://www.w3.org/TR/service-workers/#service-worker-global-scope-install-event\">https://www.w3.org/TR/service-workers</a></p>","frontmatter":{"title":"Service Worker에 대한 대략적인 이해","date":"October 31, 2023","update":"October 31, 2023","tags":["ServiceWorker","PWA"],"series":null},"fields":{"slug":"/serviceworker/","readingTime":{"minutes":15.36}}},"seriesList":{"edges":[{"node":{"id":"28f1d87e-d3fc-5567-8531-57649652864f","fields":{"slug":"/sprint-idea/"},"frontmatter":{"title":"구글 스프린트 기반 아이디어 도출"}}},{"node":{"id":"4a9246fb-171b-5973-88fc-864034e78afd","fields":{"slug":"/blog-starter/"},"frontmatter":{"title":"피움 블로그 생성과정"}}},{"node":{"id":"c826ce0e-1ea7-517c-8d19-84e90a59a798","fields":{"slug":"/jenkins-setting/"},"frontmatter":{"title":"젠킨스 설치하기"}}},{"node":{"id":"a387bf4f-567f-50e7-b6a7-99a1a1c8971b","fields":{"slug":"/jpa-notnull-nullable/"},"frontmatter":{"title":"@NotNull과 nullable = false는 어떤 차이가 있을까?"}}},{"node":{"id":"a78e224b-b711-5071-8e90-013d6f4bebc3","fields":{"slug":"/pium-deploy-step/"},"frontmatter":{"title":"피움의 배포과정"}}},{"node":{"id":"ce07fbab-1ed5-5f1e-8e2f-eb430879b56a","fields":{"slug":"/fe-tanstack-query/"},"frontmatter":{"title":"프론트엔드: Tanstack Query 사용에 대하여"}}},{"node":{"id":"159c943b-1a50-57dd-aa71-7557364752a5","fields":{"slug":"/ci-cd-setting/"},"frontmatter":{"title":"Jenkins와 Github Webhook을 이용해 CI/CD 구축하기"}}},{"node":{"id":"dea45a4a-bfde-5fbb-8a97-42d3a3e77a0b","fields":{"slug":"/jenkins-hook-by-label/"},"frontmatter":{"title":"PR 라벨로 젠킨스 빌드유발을 구분하기"}}},{"node":{"id":"1a03734e-d413-553f-9152-1dad2fc4acca","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"내 서버에 HTTPS 설정하기"}}},{"node":{"id":"cecbc8b9-db00-562b-aa0b-06c406cfc44a","fields":{"slug":"/bundle-analyze/"},"frontmatter":{"title":"bundle-analyze를 통한 bundle 크기 분석"}}},{"node":{"id":"707f8ffb-1409-5c27-b15a-5661b235c226","fields":{"slug":"/db-drop-stop/"},"frontmatter":{"title":"Table Drop 못하게 막아버리기"}}},{"node":{"id":"fe4b591a-4dd5-5dd2-b18a-b318afd1e9e3","fields":{"slug":"/transactional-not-in-restassured/"},"frontmatter":{"title":"[트러블슈팅] @SpringbootTest의 RANDOM_PORT 환경에서 @Transactional 어노테이션을 사용했을 때, RestAssured GET 요청이 수행되지 않는 경우(트랜잭션 격리 이해하기)"}}},{"node":{"id":"80aa708e-ef8a-5c79-9644-cb8c04d55a63","fields":{"slug":"/acceptance-test-resolve/"},"frontmatter":{"title":"인수테스트 데이터 초기화하기"}}},{"node":{"id":"15def1d5-c20f-5d07-b46e-24a14661365f","fields":{"slug":"/react-setting-without-cra/"},"frontmatter":{"title":"webpack으로만 React 설정하기 (without CRA)"}}},{"node":{"id":"66383c86-e2c8-533a-90e0-2effae572742","fields":{"slug":"/stylelint-and-husky/"},"frontmatter":{"title":"stylelint와 husky를 통해 컨벤션 통일하기"}}},{"node":{"id":"ed5951d5-beda-5a8f-adb2-07c2fcb38d5e","fields":{"slug":"/OAuth2.0/"},"frontmatter":{"title":"내가 이해한 OAuth2.0"}}},{"node":{"id":"45eeb9a3-557d-5704-8fd9-925283e1e27b","fields":{"slug":"/restdocs-start/"},"frontmatter":{"title":"RestDocs로 API 문서화하기"}}},{"node":{"id":"663b560a-734d-51a9-a6dc-3c4f50716c74","fields":{"slug":"/spring-event-apply/"},"frontmatter":{"title":"Spring Event 적용하기"}}},{"node":{"id":"55ae8038-3f65-5a59-8db3-c7405e7fc125","fields":{"slug":"/github-actions-cypress/"},"frontmatter":{"title":"피움 Cypress 자동화 구축기"}}},{"node":{"id":"503e9e71-eda3-53d7-8142-7c309faf213e","fields":{"slug":"/why_we_applied_querydsl/"},"frontmatter":{"title":"피움 서비스의 Querydsl 도입 이유"}}},{"node":{"id":"709124d0-5b05-5530-804d-e90ec9856a13","fields":{"slug":"/querydsl_apply_procedure/"},"frontmatter":{"title":"피움 서비스의 Querydsl 적용 과정"}}},{"node":{"id":"5c865dcb-cefd-58be-8968-b5edf6c8080c","fields":{"slug":"/server-logging/"},"frontmatter":{"title":"Logback을 이용해 운영 환경 별 로그 남기기"}}},{"node":{"id":"8269f166-d041-533c-9d44-332d8d8c3dca","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"CloudWatch를 이용한 모니터링 환경 구성"}}},{"node":{"id":"0faec7ad-3bd1-5f5e-9222-115f771df8ed","fields":{"slug":"/tanstack-query-cache-trouble-shooting/"},"frontmatter":{"title":"InfinityQuery에서 fetch가 제대로 이루어지지 않는다?!?!"}}},{"node":{"id":"c77f7199-7fc6-53a3-a1fb-0792e05655a7","fields":{"slug":"/OAuth2.0-backend/"},"frontmatter":{"title":"OAuth 2.0 로그인 구현하기 (카카오)"}}},{"node":{"id":"12e4480d-386b-5d0e-bd69-4209fed36066","fields":{"slug":"/OAuth-test-backend/"},"frontmatter":{"title":"외부 API 를 의존하는 OAuth 로그인 테스트하기"}}},{"node":{"id":"ff40e109-cc92-5d83-a213-ca9d07136d95","fields":{"slug":"/aws-s3-apply/"},"frontmatter":{"title":"AWS S3로 정적 이미지 배포하기"}}},{"node":{"id":"e343af80-72dd-5173-bbb5-5069a17d1200","fields":{"slug":"/search_in_spring_data_jpa/"},"frontmatter":{"title":"Spring Data Jpa를 활용한 검색 기능 개발하기"}}},{"node":{"id":"af344dd8-ea77-5fde-9452-a97952ce60be","fields":{"slug":"/submodule-apply/"},"frontmatter":{"title":"Git submodule을 이용한 민감정보 관리"}}},{"node":{"id":"08c9daf0-2344-52a9-8c68-31ac04c24ff0","fields":{"slug":"/tomcat-thread-config/"},"frontmatter":{"title":"톰캣 스레드 설정하기"}}},{"node":{"id":"eafed74f-ff11-5af1-a589-e9dd2ccb5c8e","fields":{"slug":"/http-cache/"},"frontmatter":{"title":"CloudFront와 HTTP 캐시"}}},{"node":{"id":"dbe47289-01f4-571d-9506-fbb92016f547","fields":{"slug":"/optimize-frontend/"},"frontmatter":{"title":"피움 최적화하기"}}},{"node":{"id":"7b830fe6-e2df-564a-926e-7f7800380336","fields":{"slug":"/query-analysis/"},"frontmatter":{"title":"서비스 내에서 발생하는 쿼리를 분석하고 개선하기"}}},{"node":{"id":"37437d15-a63e-52ef-b031-6ee1bc6fa8bc","fields":{"slug":"/image-resize/"},"frontmatter":{"title":"서버에서 이미지 리사이징하기"}}},{"node":{"id":"216f4636-4125-5765-83d8-a6a610692a41","fields":{"slug":"/dont-stop-deploy/"},"frontmatter":{"title":"무중단 배포 환경 구성하기"}}},{"node":{"id":"dd095976-5a96-51b5-9686-8956dc60cd24","fields":{"slug":"/hikaricp-connection-pool-setting/"},"frontmatter":{"title":"HikariCp Connection Pool 값 설정"}}},{"node":{"id":"625ad76f-acb1-56cc-9baa-3d6f1a954ac2","fields":{"slug":"/pwa/"},"frontmatter":{"title":"PWA를 도입해보자"}}},{"node":{"id":"6a12651c-e6b8-5fa6-9c57-766772d32680","fields":{"slug":"/serviceworker/"},"frontmatter":{"title":"Service Worker에 대한 대략적인 이해"}}}]},"previous":{"fields":{"slug":"/pwa/"},"frontmatter":{"title":"PWA를 도입해보자"}},"next":null},"pageContext":{"id":"6a12651c-e6b8-5fa6-9c57-766772d32680","series":null,"previousPostId":"625ad76f-acb1-56cc-9baa-3d6f1a954ac2","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}